// Code generated by sqlgen. DO NOT EDIT.
package financepg

import (
	"context"
	"database/sql"
	"github.com/jmoiron/sqlx"
	"github.com/masterkeysrd/saturn/internal/foundation/decimal"
	"time"
)

const (
	// GetSettingsBySpaceIDQuery is the SQL for the 'GetSettingsBySpaceID' query.
	GetSettingsBySpaceIDQuery = `
SELECT
  space_id,
  status,
  base_currency,
  create_time,
  create_by,
  update_time,
  update_by
FROM
  finance.settings
WHERE
  space_id =:space_id
LIMIT
  1;`

	// UpsertSettingsQuery is the SQL for the 'UpsertSettings' query.
	UpsertSettingsQuery = `
INSERT INTO
  finance.settings (
    space_id,
    status,
    base_currency,
    create_time,
    create_by,
    update_time,
    update_by
  )
VALUES
  (
:space_id,
:status,
:base_currency,
:create_time,
:create_by,
:update_time,
:update_by
  )
ON CONFLICT (space_id) DO UPDATE
SET
  status = EXCLUDED.status,
  base_currency = EXCLUDED.base_currency,
  update_time = EXCLUDED.update_time,
  update_by = EXCLUDED.update_by
RETURNING
  space_id,
  status,
  base_currency,
  create_time,
  create_by,
  update_time,
  update_by;`

	// GetBudgetByIDQuery is the SQL for the 'GetBudgetByID' query.
	GetBudgetByIDQuery = `
SELECT
  id,
  space_id,
  name,
  description,
  color,
  icon_name,
  status,
  amount_currency,
  amount_cents,
  create_time,
  create_by,
  update_time,
  update_by
FROM
  finance.budgets
WHERE
  id =:id
  AND space_id =:space_id
LIMIT
  1;`

	// UpsertBudgetQuery is the SQL for the 'UpsertBudget' query.
	UpsertBudgetQuery = `
INSERT INTO
  finance.budgets (
    id,
    space_id,
    name,
    description,
    color,
    icon_name,
    status,
    amount_currency,
    amount_cents,
    create_time,
    create_by,
    update_time,
    update_by
  )
VALUES
  (
:id,
:space_id,
:name,
:description,
:color,
:icon_name,
:status,
:amount_currency,
:amount_cents,
:create_time,
:create_by,
:update_time,
:update_by
  )
ON CONFLICT (id, space_id) DO UPDATE
SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  color = EXCLUDED.color,
  icon_name = EXCLUDED.icon_name,
  status = EXCLUDED.status,
  amount_currency = EXCLUDED.amount_currency,
  amount_cents = EXCLUDED.amount_cents,
  update_time = EXCLUDED.update_time,
  update_by = EXCLUDED.update_by
RETURNING
  id,
  space_id,
  name,
  description,
  color,
  icon_name,
  status,
  amount_currency,
  amount_cents,
  create_time,
  create_by,
  update_time,
  update_by;`

	// DeleteBudgetByIDQuery is the SQL for the 'DeleteBudgetByID' query.
	DeleteBudgetByIDQuery = `
DELETE FROM finance.budgets
WHERE
  id =:id
  AND space_id =:space_id;`

	// GetBudgetPeriodByDateQuery is the SQL for the 'GetBudgetPeriodByDate' query.
	GetBudgetPeriodByDateQuery = `
SELECT
  id,
  space_id,
  budget_id,
  start_date,
  end_date,
  amount_cents,
  amount_currency,
  base_amount_cents,
  base_amount_currency,
  exchange_rate,
  create_time,
  create_by,
  update_time,
  update_by
FROM
  finance.budget_periods
WHERE
  budget_id =:budget_id
  AND space_id =:space_id
  AND start_date <=:date
  AND end_date >=:date
LIMIT
  1;`

	// UpsertBudgetPeriodQuery is the SQL for the 'UpsertBudgetPeriod' query.
	UpsertBudgetPeriodQuery = `
INSERT INTO
  finance.budget_periods (
    id,
    space_id,
    budget_id,
    start_date,
    end_date,
    amount_cents,
    amount_currency,
    base_amount_cents,
    base_amount_currency,
    exchange_rate,
    create_time,
    create_by,
    update_time,
    update_by
  )
VALUES
  (
:id,
:space_id,
:budget_id,
:start_date,
:end_date,
:amount_cents,
:amount_currency,
:base_amount_cents,
:base_amount_currency,
:exchange_rate,
:create_time,
:create_by,
:update_time,
:update_by
  )
ON CONFLICT (id, space_id) DO UPDATE
SET
  start_date = EXCLUDED.start_date,
  end_date = EXCLUDED.end_date,
  amount_cents = EXCLUDED.amount_cents,
  amount_currency = EXCLUDED.amount_currency,
  base_amount_cents = EXCLUDED.base_amount_cents,
  base_amount_currency = EXCLUDED.base_amount_currency,
  exchange_rate = EXCLUDED.exchange_rate,
  update_time = EXCLUDED.update_time,
  update_by = EXCLUDED.update_by
RETURNING
  id,
  space_id,
  budget_id,
  start_date,
  end_date,
  amount_cents,
  amount_currency,
  base_amount_cents,
  base_amount_currency,
  exchange_rate,
  create_time,
  create_by,
  update_time,
  update_by;`

	// GetExchangeRateQuery is the SQL for the 'GetExchangeRate' query.
	GetExchangeRateQuery = `
SELECT
  space_id,
  currency_code,
  rate,
  is_base,
  create_time,
  create_by,
  update_time,
  update_by
FROM
  finance.exchange_rates
WHERE
  space_id =:space_id
  AND currency_code =:currency_code
LIMIT
  1;`

	// ExistsExchangeRateQuery is the SQL for the 'ExistsExchangeRate' query.
	ExistsExchangeRateQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      finance.exchange_rates
    WHERE
      space_id =:space_id
      AND currency_code =:currency_code
  ) AS EXISTS;`

	// ListExchangeRatesBySpaceIDQuery is the SQL for the 'ListExchangeRatesBySpaceID' query.
	ListExchangeRatesBySpaceIDQuery = `
SELECT
  space_id,
  currency_code,
  rate,
  is_base,
  create_time,
  create_by,
  update_time,
  update_by
FROM
  finance.exchange_rates
WHERE
  space_id =:space_id;`

	// UpsertExchangeRateQuery is the SQL for the 'UpsertExchangeRate' query.
	UpsertExchangeRateQuery = `
INSERT INTO
  finance.exchange_rates (
    space_id,
    currency_code,
    rate,
    is_base,
    create_time,
    create_by,
    update_time,
    update_by
  )
VALUES
  (
:space_id,
:currency_code,
:rate,
:is_base,
:create_time,
:create_by,
:update_time,
:update_by
  )
ON CONFLICT (space_id, currency_code) DO UPDATE
SET
  rate = EXCLUDED.rate,
  is_base = EXCLUDED.is_base,
  update_time = EXCLUDED.update_time,
  update_by = EXCLUDED.update_by
RETURNING
  space_id,
  currency_code,
  rate,
  is_base,
  create_time,
  create_by,
  update_time,
  update_by;`

	// DeleteExchangeRateQuery is the SQL for the 'DeleteExchangeRate' query.
	DeleteExchangeRateQuery = `
DELETE FROM finance.exchange_rates
WHERE
  space_id =:space_id
  AND currency_code =:currency_code;`

	// GetTransactionByIDQuery is the SQL for the 'GetTransactionByID' query.
	GetTransactionByIDQuery = `
SELECT
  id,
  space_id,
  type,
  budget_id,
  budget_period_id,
  title,
  description,
  date,
  effective_date,
  amount_cents,
  amount_currency,
  base_amount_cents,
  base_amount_currency,
  exchange_rate,
  create_time,
  create_by,
  update_time,
  update_by
FROM
  finance.transactions
WHERE
  id =:id
  AND space_id =:space_id
LIMIT
  1;`

	// ListTransactionsQuery is the SQL for the 'ListTransactions' query.
	ListTransactionsQuery = `
SELECT
  id,
  space_id,
  type,
  budget_id,
  budget_period_id,
  title,
  description,
  date,
  effective_date,
  amount_cents,
  amount_currency,
  base_amount_cents,
  base_amount_currency,
  exchange_rate,
  create_time,
  create_by,
  update_time,
  update_by
FROM
  finance.transactions
WHERE
  space_id =:space_id
ORDER BY
  date DESC,
  create_time DESC;`

	// ExistsTransactionByBudgetQuery is the SQL for the 'ExistsTransactionByBudget' query.
	ExistsTransactionByBudgetQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      finance.transactions
    WHERE
      budget_id =:budget_id
      AND space_id =:space_id
  );`

	// UpsertTransactionQuery is the SQL for the 'UpsertTransaction' query.
	UpsertTransactionQuery = `
INSERT INTO
  finance.transactions (
    id,
    space_id,
    type,
    budget_id,
    budget_period_id,
    title,
    description,
    date,
    effective_date,
    amount_cents,
    amount_currency,
    base_amount_cents,
    base_amount_currency,
    exchange_rate,
    create_time,
    create_by,
    update_time,
    update_by
  )
VALUES
  (
:id,
:space_id,
:type,
:budget_id,
:budget_period_id,
:title,
:description,
:date,
:effective_date,
:amount_cents,
:amount_currency,
:base_amount_cents,
:base_amount_currency,
:exchange_rate,
:create_time,
:create_by,
:update_time,
:update_by
  )
ON CONFLICT (id, space_id) DO UPDATE
SET
  budget_id = EXCLUDED.budget_id,
  budget_period_id = EXCLUDED.budget_period_id,
  title = EXCLUDED.title,
  description = EXCLUDED.description,
  date = EXCLUDED.date,
  effective_date = EXCLUDED.effective_date,
  amount_cents = EXCLUDED.amount_cents,
  amount_currency = EXCLUDED.amount_currency,
  base_amount_cents = EXCLUDED.base_amount_cents,
  base_amount_currency = EXCLUDED.base_amount_currency,
  exchange_rate = EXCLUDED.exchange_rate,
  update_time = EXCLUDED.update_time,
  update_by = EXCLUDED.update_by
RETURNING
  id,
  space_id,
  type,
  budget_id,
  budget_period_id,
  title,
  description,
  date,
  effective_date,
  amount_cents,
  amount_currency,
  base_amount_cents,
  base_amount_currency,
  exchange_rate,
  create_time,
  create_by,
  update_time,
  update_by;`

	// DeleteTransactionByIDQuery is the SQL for the 'DeleteTransactionByID' query.
	DeleteTransactionByIDQuery = `
DELETE FROM finance.transactions
WHERE
  id =:id
  AND space_id =:space_id;`
)

// BudgetPeriodEntity represents a row from the 'budget_periods' table.
type BudgetPeriodEntity struct {
	Id                 string          `db:"id"`
	SpaceId            string          `db:"space_id"`
	BudgetId           string          `db:"budget_id"`
	StartDate          time.Time       `db:"start_date"`
	EndDate            time.Time       `db:"end_date"`
	AmountCents        int64           `db:"amount_cents"`
	AmountCurrency     string          `db:"amount_currency"`
	BaseAmountCents    int64           `db:"base_amount_cents"`
	BaseAmountCurrency string          `db:"base_amount_currency"`
	ExchangeRate       decimal.Decimal `db:"exchange_rate"`
	CreateTime         time.Time       `db:"create_time"`
	CreateBy           string          `db:"create_by"`
	UpdateTime         time.Time       `db:"update_time"`
	UpdateBy           string          `db:"update_by"`
}

// BudgetEntity represents a row from the 'budgets' table.
type BudgetEntity struct {
	Id             string    `db:"id"`
	SpaceId        string    `db:"space_id"`
	Name           string    `db:"name"`
	Description    *string   `db:"description"`
	Color          string    `db:"color"`
	IconName       string    `db:"icon_name"`
	Status         string    `db:"status"`
	AmountCurrency string    `db:"amount_currency"`
	AmountCents    int64     `db:"amount_cents"`
	SearchVector   *any      `db:"search_vector"`
	CreateTime     time.Time `db:"create_time"`
	CreateBy       string    `db:"create_by"`
	UpdateTime     time.Time `db:"update_time"`
	UpdateBy       string    `db:"update_by"`
}

// ExchangeRateEntity represents a row from the 'exchange_rates' table.
type ExchangeRateEntity struct {
	SpaceId      string          `db:"space_id"`
	CurrencyCode string          `db:"currency_code"`
	Rate         decimal.Decimal `db:"rate"`
	IsBase       bool            `db:"is_base"`
	CreateTime   time.Time       `db:"create_time"`
	CreateBy     string          `db:"create_by"`
	UpdateTime   time.Time       `db:"update_time"`
	UpdateBy     string          `db:"update_by"`
}

// SettingEntity represents a row from the 'settings' table.
type SettingEntity struct {
	SpaceId      string    `db:"space_id"`
	Status       string    `db:"status"`
	BaseCurrency string    `db:"base_currency"`
	CreateTime   time.Time `db:"create_time"`
	CreateBy     string    `db:"create_by"`
	UpdateTime   time.Time `db:"update_time"`
	UpdateBy     string    `db:"update_by"`
}

// TransactionEntity represents a row from the 'transactions' table.
type TransactionEntity struct {
	Id                 string          `db:"id"`
	SpaceId            string          `db:"space_id"`
	Type               string          `db:"type"`
	BudgetId           *string         `db:"budget_id"`
	BudgetPeriodId     *string         `db:"budget_period_id"`
	Title              string          `db:"title"`
	Description        *string         `db:"description"`
	Date               time.Time       `db:"date"`
	EffectiveDate      time.Time       `db:"effective_date"`
	AmountCents        int64           `db:"amount_cents"`
	AmountCurrency     string          `db:"amount_currency"`
	BaseAmountCents    int64           `db:"base_amount_cents"`
	BaseAmountCurrency string          `db:"base_amount_currency"`
	ExchangeRate       decimal.Decimal `db:"exchange_rate"`
	SearchVector       *any            `db:"search_vector"`
	CreateTime         time.Time       `db:"create_time"`
	CreateBy           string          `db:"create_by"`
	UpdateTime         time.Time       `db:"update_time"`
	UpdateBy           string          `db:"update_by"`
}

// GetSettingsBySpaceIDParams represents the parameters for the 'GetSettingsBySpaceID' query.
type GetSettingsBySpaceIDParams struct {
	SpaceId string `db:"space_id"`
}

// UpsertSettingsParams represents the parameters for the 'UpsertSettings' query.
//
// UpsertSettingsParams is an alias of [SettingEntity].
type UpsertSettingsParams = SettingEntity

// GetBudgetByIDParams represents the parameters for the 'GetBudgetByID' query.
type GetBudgetByIDParams struct {
	Id      string `db:"id"`
	SpaceId string `db:"space_id"`
}

// UpsertBudgetParams represents the parameters for the 'UpsertBudget' query.
//
// UpsertBudgetParams is an alias of [BudgetEntity].
type UpsertBudgetParams = BudgetEntity

// DeleteBudgetByIDParams represents the parameters for the 'DeleteBudgetByID' query.
type DeleteBudgetByIDParams struct {
	Id      string `db:"id"`
	SpaceId string `db:"space_id"`
}

// GetBudgetPeriodByDateParams represents the parameters for the 'GetBudgetPeriodByDate' query.
type GetBudgetPeriodByDateParams struct {
	BudgetId string    `db:"budget_id"`
	SpaceId  string    `db:"space_id"`
	Date     time.Time `db:"date"`
}

// UpsertBudgetPeriodParams represents the parameters for the 'UpsertBudgetPeriod' query.
//
// UpsertBudgetPeriodParams is an alias of [BudgetPeriodEntity].
type UpsertBudgetPeriodParams = BudgetPeriodEntity

// GetExchangeRateParams represents the parameters for the 'GetExchangeRate' query.
type GetExchangeRateParams struct {
	SpaceId      string `db:"space_id"`
	CurrencyCode string `db:"currency_code"`
}

// ExistsExchangeRateParams represents the parameters for the 'ExistsExchangeRate' query.
type ExistsExchangeRateParams struct {
	SpaceId      string `db:"space_id"`
	CurrencyCode string `db:"currency_code"`
}

// ListExchangeRatesBySpaceIDParams represents the parameters for the 'ListExchangeRatesBySpaceID' query.
type ListExchangeRatesBySpaceIDParams struct {
	SpaceId string `db:"space_id"`
}

// UpsertExchangeRateParams represents the parameters for the 'UpsertExchangeRate' query.
//
// UpsertExchangeRateParams is an alias of [ExchangeRateEntity].
type UpsertExchangeRateParams = ExchangeRateEntity

// DeleteExchangeRateParams represents the parameters for the 'DeleteExchangeRate' query.
type DeleteExchangeRateParams struct {
	SpaceId      string `db:"space_id"`
	CurrencyCode string `db:"currency_code"`
}

// GetTransactionByIDParams represents the parameters for the 'GetTransactionByID' query.
type GetTransactionByIDParams struct {
	Id      string `db:"id"`
	SpaceId string `db:"space_id"`
}

// ListTransactionsParams represents the parameters for the 'ListTransactions' query.
type ListTransactionsParams struct {
	SpaceId string `db:"space_id"`
}

// ExistsTransactionByBudgetParams represents the parameters for the 'ExistsTransactionByBudget' query.
type ExistsTransactionByBudgetParams struct {
	BudgetId *string `db:"budget_id"`
	SpaceId  string  `db:"space_id"`
}

// UpsertTransactionParams represents the parameters for the 'UpsertTransaction' query.
//
// UpsertTransactionParams is an alias of [TransactionEntity].
type UpsertTransactionParams = TransactionEntity

// DeleteTransactionByIDParams represents the parameters for the 'DeleteTransactionByID' query.
type DeleteTransactionByIDParams struct {
	Id      string `db:"id"`
	SpaceId string `db:"space_id"`
}

// GetSettingsBySpaceID executes the 'GetSettingsBySpaceID' query and returns a single row.
func GetSettingsBySpaceID(ctx context.Context, db sqlx.ExtContext, params *GetSettingsBySpaceIDParams) (*SettingEntity, error) {
	query, args, err := sqlx.Named(GetSettingsBySpaceIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item SettingEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// UpsertSettings executes the 'UpsertSettings' query and returns a single row.
func UpsertSettings(ctx context.Context, db sqlx.ExtContext, params *UpsertSettingsParams) (*SettingEntity, error) {
	query, args, err := sqlx.Named(UpsertSettingsQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item SettingEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// GetBudgetByID executes the 'GetBudgetByID' query and returns a single row.
func GetBudgetByID(ctx context.Context, db sqlx.ExtContext, params *GetBudgetByIDParams) (*BudgetEntity, error) {
	query, args, err := sqlx.Named(GetBudgetByIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item BudgetEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// UpsertBudget executes the 'UpsertBudget' query and returns a single row.
func UpsertBudget(ctx context.Context, db sqlx.ExtContext, params *UpsertBudgetParams) (*BudgetEntity, error) {
	query, args, err := sqlx.Named(UpsertBudgetQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item BudgetEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// DeleteBudgetByID executes the 'DeleteBudgetByID' query.
func DeleteBudgetByID(ctx context.Context, e sqlx.ExtContext, params *DeleteBudgetByIDParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, DeleteBudgetByIDQuery, params)
}

// GetBudgetPeriodByDate executes the 'GetBudgetPeriodByDate' query and returns a single row.
func GetBudgetPeriodByDate(ctx context.Context, db sqlx.ExtContext, params *GetBudgetPeriodByDateParams) (*BudgetPeriodEntity, error) {
	query, args, err := sqlx.Named(GetBudgetPeriodByDateQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item BudgetPeriodEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// UpsertBudgetPeriod executes the 'UpsertBudgetPeriod' query and returns a single row.
func UpsertBudgetPeriod(ctx context.Context, db sqlx.ExtContext, params *UpsertBudgetPeriodParams) (*BudgetPeriodEntity, error) {
	query, args, err := sqlx.Named(UpsertBudgetPeriodQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item BudgetPeriodEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// GetExchangeRate executes the 'GetExchangeRate' query and returns a single row.
func GetExchangeRate(ctx context.Context, db sqlx.ExtContext, params *GetExchangeRateParams) (*ExchangeRateEntity, error) {
	query, args, err := sqlx.Named(GetExchangeRateQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item ExchangeRateEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// ExistsExchangeRate executes the 'ExistsExchangeRate' query and returns a single row.
func ExistsExchangeRate(ctx context.Context, db sqlx.ExtContext, params *ExistsExchangeRateParams) (bool, error) {
	query, args, err := sqlx.Named(ExistsExchangeRateQuery, params)
	if err != nil {
		return false, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item bool
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return false, err
	}

	return item, nil
}

// ListExchangeRatesBySpaceID executes the 'ListExchangeRatesBySpaceID' query and returns multiple rows.
func ListExchangeRatesBySpaceID(ctx context.Context, db sqlx.ExtContext, params *ListExchangeRatesBySpaceIDParams, mapper func(*ExchangeRateEntity) error) error {
	rows, err := sqlx.NamedQueryContext(ctx, db, ListExchangeRatesBySpaceIDQuery, params)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var item ExchangeRateEntity
		if err := rows.StructScan(&item); err != nil {
			return err
		}
		if err := mapper(&item); err != nil {
			return err
		}
	}

	return rows.Err()
}

// UpsertExchangeRate executes the 'UpsertExchangeRate' query and returns a single row.
func UpsertExchangeRate(ctx context.Context, db sqlx.ExtContext, params *UpsertExchangeRateParams) (*ExchangeRateEntity, error) {
	query, args, err := sqlx.Named(UpsertExchangeRateQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item ExchangeRateEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// DeleteExchangeRate executes the 'DeleteExchangeRate' query.
func DeleteExchangeRate(ctx context.Context, e sqlx.ExtContext, params *DeleteExchangeRateParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, DeleteExchangeRateQuery, params)
}

// GetTransactionByID executes the 'GetTransactionByID' query and returns a single row.
func GetTransactionByID(ctx context.Context, db sqlx.ExtContext, params *GetTransactionByIDParams) (*TransactionEntity, error) {
	query, args, err := sqlx.Named(GetTransactionByIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item TransactionEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// ListTransactions executes the 'ListTransactions' query and returns multiple rows.
func ListTransactions(ctx context.Context, db sqlx.ExtContext, params *ListTransactionsParams, mapper func(*TransactionEntity) error) error {
	rows, err := sqlx.NamedQueryContext(ctx, db, ListTransactionsQuery, params)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var item TransactionEntity
		if err := rows.StructScan(&item); err != nil {
			return err
		}
		if err := mapper(&item); err != nil {
			return err
		}
	}

	return rows.Err()
}

// ExistsTransactionByBudget executes the 'ExistsTransactionByBudget' query and returns a single row.
func ExistsTransactionByBudget(ctx context.Context, db sqlx.ExtContext, params *ExistsTransactionByBudgetParams) (bool, error) {
	query, args, err := sqlx.Named(ExistsTransactionByBudgetQuery, params)
	if err != nil {
		return false, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item bool
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return false, err
	}

	return item, nil
}

// UpsertTransaction executes the 'UpsertTransaction' query and returns a single row.
func UpsertTransaction(ctx context.Context, db sqlx.ExtContext, params *UpsertTransactionParams) (*TransactionEntity, error) {
	query, args, err := sqlx.Named(UpsertTransactionQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item TransactionEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// DeleteTransactionByID executes the 'DeleteTransactionByID' query.
func DeleteTransactionByID(ctx context.Context, e sqlx.ExtContext, params *DeleteTransactionByIDParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, DeleteTransactionByIDQuery, params)
}
