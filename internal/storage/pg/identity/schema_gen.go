// Code generated by sqlgen. DO NOT EDIT.
package identitypg

import (
	"time"
)

const (
	// GetUserByIDQuery is the SQL for the 'GetUserByID' query.
	GetUserByIDQuery = `
SELECT
  id,
  name,
  avatar_url,
  username,
  email,
  role,
  status,
  create_time,
  update_time,
  delete_time
FROM
  identity.users
WHERE
  id =:id;`

	// UpsertUserQuery is the SQL for the 'UpsertUser' query.
	UpsertUserQuery = `
INSERT INTO
  identity.users (
    id,
    name,
    avatar_url,
    username,
    email,
    role,
    status,
    create_time,
    update_time,
    delete_time
  )
VALUES
  (
:id,
:name,
:avatar_url,
:username,
:email,
:role,
:status,
:create_time,
:update_time,
:delete_time
  )
ON CONFLICT (id) DO UPDATE
SET
  name = EXCLUDED.name,
  avatar_url = EXCLUDED.avatar_url,
  username = EXCLUDED.username,
  email = EXCLUDED.email,
  role = EXCLUDED.role,
  status = EXCLUDED.status,
  update_time = EXCLUDED.update_time,
  delete_time = EXCLUDED.delete_time;`

	// ExistsUserByUsernameQuery is the SQL for the 'ExistsUserByUsername' query.
	ExistsUserByUsernameQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.users
    WHERE
      username =:username
  );`

	// ExistsUserByEmailQuery is the SQL for the 'ExistsUserByEmail' query.
	ExistsUserByEmailQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.users
    WHERE
      email =:email
  );`

	// GetSessionByIDQuery is the SQL for the 'GetSessionByID' query.
	GetSessionByIDQuery = `
SELECT
  id,
  user_id,
  token_hash,
  user_agent,
  client_ip,
  expires_at,
  create_time,
  update_time
FROM
  identity.sessions
WHERE
  id =:id;`

	// UpsertSessionQuery is the SQL for the 'UpsertSession' query.
	UpsertSessionQuery = `
INSERT INTO
  identity.sessions (
    id,
    user_id,
    token_hash,
    user_agent,
    client_ip,
    expires_at,
    create_time,
    update_time
  )
VALUES
  (
:id,
:user_id,
:token_hash,
:user_agent,
:client_ip,
:expires_at,
:create_time,
:update_time
  )
ON CONFLICT (id) DO UPDATE
SET
  user_id = EXCLUDED.user_id,
  token_hash = EXCLUDED.token_hash,
  user_agent = EXCLUDED.user_agent,
  client_ip = EXCLUDED.client_ip,
  expires_at = EXCLUDED.expires_at,
  update_time = EXCLUDED.update_time;`

	// DeleteSessionByIDQuery is the SQL for the 'DeleteSessionByID' query.
	DeleteSessionByIDQuery = `
DELETE FROM identity.sessions
WHERE
  id =:id;`

	// DeleteSessionsByUserIDQuery is the SQL for the 'DeleteSessionsByUserID' query.
	DeleteSessionsByUserIDQuery = `
DELETE FROM identity.sessions
WHERE
  user_id =:user_id;`

	// GetBindingByIDQuery is the SQL for the 'GetBindingByID' query.
	GetBindingByIDQuery = `
SELECT
  user_id,
  provider,
  subject_id,
  create_time,
  update_time
FROM
  identity.bindings
WHERE
  user_id =:user_id
  AND provider =:provider;`

	// GetBindingByProviderAndSubjectIDQuery is the SQL for the 'GetBindingByProviderAndSubjectID' query.
	GetBindingByProviderAndSubjectIDQuery = `
SELECT
  user_id,
  provider,
  subject_id,
  create_time,
  update_time
FROM
  identity.bindings
WHERE
  provider =:provider
  AND subject_id =:subject_id;`

	// ListBindingsByUserIDQuery is the SQL for the 'ListBindingsByUserID' query.
	ListBindingsByUserIDQuery = `
SELECT
  user_id,
  provider,
  subject_id,
  create_time,
  update_time
FROM
  identity.bindings
WHERE
  user_id =:user_id
ORDER BY
  provider ASC;`

	// UpsertBindingQuery is the SQL for the 'UpsertBinding' query.
	UpsertBindingQuery = `
INSERT INTO
  identity.bindings (
    user_id,
    provider,
    subject_id,
    create_time,
    update_time
  )
VALUES
  (
:user_id,
:provider,
:subject_id,
:create_time,
:update_time
  )
ON CONFLICT (user_id, provider) DO UPDATE
SET
  subject_id = EXCLUDED.subject_id,
  update_time = EXCLUDED.update_time;`

	// DeleteBindingQuery is the SQL for the 'DeleteBinding' query.
	DeleteBindingQuery = `
DELETE FROM identity.bindings
WHERE
  user_id =:user_id
  AND provider =:provider;`

	// GetCredentialsBySubjectIDQuery is the SQL for the 'GetCredentialsBySubjectID' query.
	GetCredentialsBySubjectIDQuery = `
SELECT
  subject_id,
  username,
  email,
  password_hash,
  create_time,
  update_time
FROM
  identity.vault_credentials
WHERE
  subject_id =:subject_id;`

	// GetCredentialsByIdentifierQuery is the SQL for the 'GetCredentialsByIdentifier' query.
	GetCredentialsByIdentifierQuery = `
SELECT
  subject_id,
  username,
  email,
  password_hash,
  create_time,
  update_time
FROM
  identity.vault_credentials
WHERE
  username =:identifier
  OR email =:identifier;`

	// ExistsCredentialsByUsernameQuery is the SQL for the 'ExistsCredentialsByUsername' query.
	ExistsCredentialsByUsernameQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.vault_credentials
    WHERE
      username =:username
  );`

	// ExistsCredentialsByEmailQuery is the SQL for the 'ExistsCredentialsByEmail' query.
	ExistsCredentialsByEmailQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.vault_credentials
    WHERE
      email =:email
  );`

	// UpsertCredentialsQuery is the SQL for the 'UpsertCredentials' query.
	UpsertCredentialsQuery = `
INSERT INTO
  identity.vault_credentials (
    subject_id,
    username,
    email,
    password_hash,
    create_time,
    update_time
  )
VALUES
  (
:subject_id,
:username,
:email,
:password_hash,
:create_time,
:update_time
  )
ON CONFLICT (subject_id) DO UPDATE
SET
  username = EXCLUDED.username,
  email = EXCLUDED.email,
  password_hash = EXCLUDED.password_hash,
  update_time = EXCLUDED.update_time;`
)

// BindingEntity represents a row from the 'bindings' table.
type BindingEntity struct {
	UserID     string    `db:"user_id"`
	Provider   string    `db:"provider"`
	SubjectID  string    `db:"subject_id"`
	CreateTime time.Time `db:"create_time"`
	UpdateTime time.Time `db:"update_time"`
}

// SessionEntity represents a row from the 'sessions' table.
type SessionEntity struct {
	ID         string    `db:"id"`
	UserID     string    `db:"user_id"`
	TokenHash  string    `db:"token_hash"`
	UserAgent  *string   `db:"user_agent"`
	ClientIP   *string   `db:"client_ip"`
	ExpireTime time.Time `db:"expire_time"`
	CreateTime time.Time `db:"create_time"`
	UpdateTime time.Time `db:"update_time"`
}

// UserEntity represents a row from the 'users' table.
type UserEntity struct {
	ID         string     `db:"id"`
	Name       string     `db:"name"`
	AvatarURL  *string    `db:"avatar_url"`
	Username   string     `db:"username"`
	Email      string     `db:"email"`
	Role       string     `db:"role"`
	Status     string     `db:"status"`
	CreateTime time.Time  `db:"create_time"`
	UpdateTime time.Time  `db:"update_time"`
	DeleteTime *time.Time `db:"delete_time"`
}

// VaultCredentialEntity represents a row from the 'vault_credentials' table.
type VaultCredentialEntity struct {
	SubjectID    string    `db:"subject_id"`
	Username     string    `db:"username"`
	Email        string    `db:"email"`
	PasswordHash string    `db:"password_hash"`
	CreateTime   time.Time `db:"create_time"`
	UpdateTime   time.Time `db:"update_time"`
}

// GetUserByIDParams represents the parameters for the 'GetUserByID' query.
type GetUserByIDParams struct {
	ID string `db:"id"`
}

// UpsertUserParams represents the parameters for the 'UpsertUser' query.
//
// UpsertUserParams is an alias of [UserEntity].
type UpsertUserParams = UserEntity

// ExistsUserByUsernameParams represents the parameters for the 'ExistsUserByUsername' query.
type ExistsUserByUsernameParams struct {
	Username string `db:"username"`
}

// ExistsUserByEmailParams represents the parameters for the 'ExistsUserByEmail' query.
type ExistsUserByEmailParams struct {
	Email string `db:"email"`
}

// GetSessionByIDParams represents the parameters for the 'GetSessionByID' query.
type GetSessionByIDParams struct {
	ID string `db:"id"`
}

// UpsertSessionParams represents the parameters for the 'UpsertSession' query.
//
// UpsertSessionParams is an alias of [SessionEntity].
type UpsertSessionParams = SessionEntity

// DeleteSessionByIDParams represents the parameters for the 'DeleteSessionByID' query.
type DeleteSessionByIDParams struct {
	ID string `db:"id"`
}

// DeleteSessionsByUserIDParams represents the parameters for the 'DeleteSessionsByUserID' query.
type DeleteSessionsByUserIDParams struct {
	UserID string `db:"user_id"`
}

// GetBindingByIDParams represents the parameters for the 'GetBindingByID' query.
type GetBindingByIDParams struct {
	UserID   string `db:"user_id"`
	Provider string `db:"provider"`
}

// GetBindingByProviderAndSubjectIDParams represents the parameters for the 'GetBindingByProviderAndSubjectID' query.
type GetBindingByProviderAndSubjectIDParams struct {
	Provider  string `db:"provider"`
	SubjectID string `db:"subject_id"`
}

// ListBindingsByUserIDParams represents the parameters for the 'ListBindingsByUserID' query.
type ListBindingsByUserIDParams struct {
	UserID string `db:"user_id"`
}

// UpsertBindingParams represents the parameters for the 'UpsertBinding' query.
//
// UpsertBindingParams is an alias of [BindingEntity].
type UpsertBindingParams = BindingEntity

// DeleteBindingParams represents the parameters for the 'DeleteBinding' query.
type DeleteBindingParams struct {
	UserID   string `db:"user_id"`
	Provider string `db:"provider"`
}

// GetCredentialsBySubjectIDParams represents the parameters for the 'GetCredentialsBySubjectID' query.
type GetCredentialsBySubjectIDParams struct {
	SubjectID string `db:"subject_id"`
}

// GetCredentialsByIdentifierParams represents the parameters for the 'GetCredentialsByIdentifier' query.
type GetCredentialsByIdentifierParams struct {
	Identifier string `db:"identifier"`
}

// ExistsCredentialsByUsernameParams represents the parameters for the 'ExistsCredentialsByUsername' query.
type ExistsCredentialsByUsernameParams struct {
	Username string `db:"username"`
}

// ExistsCredentialsByEmailParams represents the parameters for the 'ExistsCredentialsByEmail' query.
type ExistsCredentialsByEmailParams struct {
	Email string `db:"email"`
}

// UpsertCredentialsParams represents the parameters for the 'UpsertCredentials' query.
//
// UpsertCredentialsParams is an alias of [VaultCredentialEntity].
type UpsertCredentialsParams = VaultCredentialEntity
