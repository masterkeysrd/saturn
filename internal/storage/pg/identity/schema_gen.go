// Code generated by sqlgen. DO NOT EDIT.
package identitypg

import (
	"context"
	"database/sql"
	"github.com/jmoiron/sqlx"
	"time"
)

const (
	// GetUserByIDQuery is the SQL for the 'GetUserByID' query.
	GetUserByIDQuery = `
SELECT
  id,
  name,
  avatar_url,
  username,
  email,
  role,
  status,
  create_time,
  update_time,
  delete_time
FROM
  identity.users
WHERE
  id =:id;`

	// UpsertUserQuery is the SQL for the 'UpsertUser' query.
	UpsertUserQuery = `
INSERT INTO
  identity.users (
    id,
    name,
    avatar_url,
    username,
    email,
    role,
    status,
    create_time,
    update_time,
    delete_time
  )
VALUES
  (
:id,
:name,
:avatar_url,
:username,
:email,
:role,
:status,
:create_time,
:update_time,
:delete_time
  )
ON CONFLICT (id) DO UPDATE
SET
  name = EXCLUDED.name,
  avatar_url = EXCLUDED.avatar_url,
  username = EXCLUDED.username,
  email = EXCLUDED.email,
  role = EXCLUDED.role,
  status = EXCLUDED.status,
  update_time = EXCLUDED.update_time,
  delete_time = EXCLUDED.delete_time;`

	// ExistsUserByUsernameQuery is the SQL for the 'ExistsUserByUsername' query.
	ExistsUserByUsernameQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.users
    WHERE
      username =:username
  );`

	// ExistsUserByEmailQuery is the SQL for the 'ExistsUserByEmail' query.
	ExistsUserByEmailQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.users
    WHERE
      email =:email
  );`

	// GetSessionByIDQuery is the SQL for the 'GetSessionByID' query.
	GetSessionByIDQuery = `
SELECT
  id,
  user_id,
  token_hash,
  user_agent,
  client_ip,
  expire_time,
  create_time,
  update_time
FROM
  identity.sessions
WHERE
  id =:id;`

	// UpsertSessionQuery is the SQL for the 'UpsertSession' query.
	UpsertSessionQuery = `
INSERT INTO
  identity.sessions (
    id,
    user_id,
    token_hash,
    user_agent,
    client_ip,
    expire_time,
    create_time,
    update_time
  )
VALUES
  (
:id,
:user_id,
:token_hash,
:user_agent,
:client_ip,
:expire_time,
:create_time,
:update_time
  )
ON CONFLICT (id) DO UPDATE
SET
  user_id = EXCLUDED.user_id,
  token_hash = EXCLUDED.token_hash,
  user_agent = EXCLUDED.user_agent,
  client_ip = EXCLUDED.client_ip,
  expire_time = EXCLUDED.expire_time,
  update_time = EXCLUDED.update_time;`

	// DeleteSessionByIDQuery is the SQL for the 'DeleteSessionByID' query.
	DeleteSessionByIDQuery = `
DELETE FROM identity.sessions
WHERE
  id =:id;`

	// DeleteSessionsByUserIDQuery is the SQL for the 'DeleteSessionsByUserID' query.
	DeleteSessionsByUserIDQuery = `
DELETE FROM identity.sessions
WHERE
  user_id =:user_id;`

	// GetBindingByIDQuery is the SQL for the 'GetBindingByID' query.
	GetBindingByIDQuery = `
SELECT
  user_id,
  provider,
  subject_id,
  create_time,
  update_time
FROM
  identity.bindings
WHERE
  user_id =:user_id
  AND provider =:provider;`

	// GetBindingByProviderAndSubjectIDQuery is the SQL for the 'GetBindingByProviderAndSubjectID' query.
	GetBindingByProviderAndSubjectIDQuery = `
SELECT
  user_id,
  provider,
  subject_id,
  create_time,
  update_time
FROM
  identity.bindings
WHERE
  provider =:provider
  AND subject_id =:subject_id;`

	// ListBindingsByUserIDQuery is the SQL for the 'ListBindingsByUserID' query.
	ListBindingsByUserIDQuery = `
SELECT
  user_id,
  provider,
  subject_id,
  create_time,
  update_time
FROM
  identity.bindings
WHERE
  user_id =:user_id
ORDER BY
  provider ASC;`

	// UpsertBindingQuery is the SQL for the 'UpsertBinding' query.
	UpsertBindingQuery = `
INSERT INTO
  identity.bindings (
    user_id,
    provider,
    subject_id,
    create_time,
    update_time
  )
VALUES
  (
:user_id,
:provider,
:subject_id,
:create_time,
:update_time
  )
ON CONFLICT (user_id, provider) DO UPDATE
SET
  subject_id = EXCLUDED.subject_id,
  update_time = EXCLUDED.update_time;`

	// DeleteBindingQuery is the SQL for the 'DeleteBinding' query.
	DeleteBindingQuery = `
DELETE FROM identity.bindings
WHERE
  user_id =:user_id
  AND provider =:provider;`

	// GetCredentialsBySubjectIDQuery is the SQL for the 'GetCredentialsBySubjectID' query.
	GetCredentialsBySubjectIDQuery = `
SELECT
  subject_id,
  username,
  email,
  password_hash,
  create_time,
  update_time
FROM
  identity.vault_credentials
WHERE
  subject_id =:subject_id;`

	// GetCredentialsByIdentifierQuery is the SQL for the 'GetCredentialsByIdentifier' query.
	GetCredentialsByIdentifierQuery = `
SELECT
  subject_id,
  username,
  email,
  password_hash,
  create_time,
  update_time
FROM
  identity.vault_credentials
WHERE
  username =:identifier
  OR email =:identifier;`

	// ExistsCredentialsByUsernameQuery is the SQL for the 'ExistsCredentialsByUsername' query.
	ExistsCredentialsByUsernameQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.vault_credentials
    WHERE
      username =:username
  );`

	// ExistsCredentialsByEmailQuery is the SQL for the 'ExistsCredentialsByEmail' query.
	ExistsCredentialsByEmailQuery = `
SELECT
  EXISTS (
    SELECT
      1
    FROM
      identity.vault_credentials
    WHERE
      email =:email
  );`

	// UpsertCredentialsQuery is the SQL for the 'UpsertCredentials' query.
	UpsertCredentialsQuery = `
INSERT INTO
  identity.vault_credentials (
    subject_id,
    username,
    email,
    password_hash,
    create_time,
    update_time
  )
VALUES
  (
:subject_id,
:username,
:email,
:password_hash,
:create_time,
:update_time
  )
ON CONFLICT (subject_id) DO UPDATE
SET
  username = EXCLUDED.username,
  email = EXCLUDED.email,
  password_hash = EXCLUDED.password_hash,
  update_time = EXCLUDED.update_time;`
)

// BindingEntity represents a row from the 'bindings' table.
type BindingEntity struct {
	UserId     string    `db:"user_id"`
	Provider   string    `db:"provider"`
	SubjectId  string    `db:"subject_id"`
	CreateTime time.Time `db:"create_time"`
	UpdateTime time.Time `db:"update_time"`
}

// SessionEntity represents a row from the 'sessions' table.
type SessionEntity struct {
	Id         string    `db:"id"`
	UserId     string    `db:"user_id"`
	TokenHash  string    `db:"token_hash"`
	UserAgent  *string   `db:"user_agent"`
	ClientIp   *string   `db:"client_ip"`
	ExpireTime time.Time `db:"expire_time"`
	CreateTime time.Time `db:"create_time"`
	UpdateTime time.Time `db:"update_time"`
}

// UserEntity represents a row from the 'users' table.
type UserEntity struct {
	Id         string     `db:"id"`
	Name       string     `db:"name"`
	AvatarUrl  *string    `db:"avatar_url"`
	Username   string     `db:"username"`
	Email      string     `db:"email"`
	Role       string     `db:"role"`
	Status     string     `db:"status"`
	CreateTime time.Time  `db:"create_time"`
	UpdateTime time.Time  `db:"update_time"`
	DeleteTime *time.Time `db:"delete_time"`
}

// VaultCredentialEntity represents a row from the 'vault_credentials' table.
type VaultCredentialEntity struct {
	SubjectId    string    `db:"subject_id"`
	Username     string    `db:"username"`
	Email        string    `db:"email"`
	PasswordHash string    `db:"password_hash"`
	CreateTime   time.Time `db:"create_time"`
	UpdateTime   time.Time `db:"update_time"`
}

// GetUserByIDParams represents the parameters for the 'GetUserByID' query.
type GetUserByIDParams struct {
	Id string `db:"id"`
}

// UpsertUserParams represents the parameters for the 'UpsertUser' query.
//
// UpsertUserParams is an alias of [UserEntity].
type UpsertUserParams = UserEntity

// ExistsUserByUsernameParams represents the parameters for the 'ExistsUserByUsername' query.
type ExistsUserByUsernameParams struct {
	Username string `db:"username"`
}

// ExistsUserByEmailParams represents the parameters for the 'ExistsUserByEmail' query.
type ExistsUserByEmailParams struct {
	Email string `db:"email"`
}

// GetSessionByIDParams represents the parameters for the 'GetSessionByID' query.
type GetSessionByIDParams struct {
	Id string `db:"id"`
}

// UpsertSessionParams represents the parameters for the 'UpsertSession' query.
//
// UpsertSessionParams is an alias of [SessionEntity].
type UpsertSessionParams = SessionEntity

// DeleteSessionByIDParams represents the parameters for the 'DeleteSessionByID' query.
type DeleteSessionByIDParams struct {
	Id string `db:"id"`
}

// DeleteSessionsByUserIDParams represents the parameters for the 'DeleteSessionsByUserID' query.
type DeleteSessionsByUserIDParams struct {
	UserId string `db:"user_id"`
}

// GetBindingByIDParams represents the parameters for the 'GetBindingByID' query.
type GetBindingByIDParams struct {
	UserId   string `db:"user_id"`
	Provider string `db:"provider"`
}

// GetBindingByProviderAndSubjectIDParams represents the parameters for the 'GetBindingByProviderAndSubjectID' query.
type GetBindingByProviderAndSubjectIDParams struct {
	Provider  string `db:"provider"`
	SubjectId string `db:"subject_id"`
}

// ListBindingsByUserIDParams represents the parameters for the 'ListBindingsByUserID' query.
type ListBindingsByUserIDParams struct {
	UserId string `db:"user_id"`
}

// UpsertBindingParams represents the parameters for the 'UpsertBinding' query.
//
// UpsertBindingParams is an alias of [BindingEntity].
type UpsertBindingParams = BindingEntity

// DeleteBindingParams represents the parameters for the 'DeleteBinding' query.
type DeleteBindingParams struct {
	UserId   string `db:"user_id"`
	Provider string `db:"provider"`
}

// GetCredentialsBySubjectIDParams represents the parameters for the 'GetCredentialsBySubjectID' query.
type GetCredentialsBySubjectIDParams struct {
	SubjectId string `db:"subject_id"`
}

// GetCredentialsByIdentifierParams represents the parameters for the 'GetCredentialsByIdentifier' query.
type GetCredentialsByIdentifierParams struct {
	Identifier string `db:"identifier"`
}

// ExistsCredentialsByUsernameParams represents the parameters for the 'ExistsCredentialsByUsername' query.
type ExistsCredentialsByUsernameParams struct {
	Username string `db:"username"`
}

// ExistsCredentialsByEmailParams represents the parameters for the 'ExistsCredentialsByEmail' query.
type ExistsCredentialsByEmailParams struct {
	Email string `db:"email"`
}

// UpsertCredentialsParams represents the parameters for the 'UpsertCredentials' query.
//
// UpsertCredentialsParams is an alias of [VaultCredentialEntity].
type UpsertCredentialsParams = VaultCredentialEntity

// GetUserByID executes the 'GetUserByID' query and returns a single row.
func GetUserByID(ctx context.Context, db sqlx.ExtContext, params *GetUserByIDParams) (*UserEntity, error) {
	query, args, err := sqlx.Named(GetUserByIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item UserEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// UpsertUser executes the 'UpsertUser' query.
func UpsertUser(ctx context.Context, e sqlx.ExtContext, params *UpsertUserParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, UpsertUserQuery, params)
}

// ExistsUserByUsername executes the 'ExistsUserByUsername' query and returns a single row.
func ExistsUserByUsername(ctx context.Context, db sqlx.ExtContext, params *ExistsUserByUsernameParams) (bool, error) {
	query, args, err := sqlx.Named(ExistsUserByUsernameQuery, params)
	if err != nil {
		return false, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item bool
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return false, err
	}

	return item, nil
}

// ExistsUserByEmail executes the 'ExistsUserByEmail' query and returns a single row.
func ExistsUserByEmail(ctx context.Context, db sqlx.ExtContext, params *ExistsUserByEmailParams) (bool, error) {
	query, args, err := sqlx.Named(ExistsUserByEmailQuery, params)
	if err != nil {
		return false, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item bool
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return false, err
	}

	return item, nil
}

// GetSessionByID executes the 'GetSessionByID' query and returns a single row.
func GetSessionByID(ctx context.Context, db sqlx.ExtContext, params *GetSessionByIDParams) (*SessionEntity, error) {
	query, args, err := sqlx.Named(GetSessionByIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item SessionEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// UpsertSession executes the 'UpsertSession' query.
func UpsertSession(ctx context.Context, e sqlx.ExtContext, params *UpsertSessionParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, UpsertSessionQuery, params)
}

// DeleteSessionByID executes the 'DeleteSessionByID' query.
func DeleteSessionByID(ctx context.Context, e sqlx.ExtContext, params *DeleteSessionByIDParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, DeleteSessionByIDQuery, params)
}

// DeleteSessionsByUserID executes the 'DeleteSessionsByUserID' query.
func DeleteSessionsByUserID(ctx context.Context, e sqlx.ExtContext, params *DeleteSessionsByUserIDParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, DeleteSessionsByUserIDQuery, params)
}

// GetBindingByID executes the 'GetBindingByID' query and returns a single row.
func GetBindingByID(ctx context.Context, db sqlx.ExtContext, params *GetBindingByIDParams) (*BindingEntity, error) {
	query, args, err := sqlx.Named(GetBindingByIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item BindingEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// GetBindingByProviderAndSubjectID executes the 'GetBindingByProviderAndSubjectID' query and returns a single row.
func GetBindingByProviderAndSubjectID(ctx context.Context, db sqlx.ExtContext, params *GetBindingByProviderAndSubjectIDParams) (*BindingEntity, error) {
	query, args, err := sqlx.Named(GetBindingByProviderAndSubjectIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item BindingEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// ListBindingsByUserID executes the 'ListBindingsByUserID' query and returns multiple rows.
func ListBindingsByUserID(ctx context.Context, db sqlx.ExtContext, params *ListBindingsByUserIDParams, mapper func(*BindingEntity) error) error {
	rows, err := sqlx.NamedQueryContext(ctx, db, ListBindingsByUserIDQuery, params)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var item BindingEntity
		if err := rows.StructScan(&item); err != nil {
			return err
		}
		if err := mapper(&item); err != nil {
			return err
		}
	}

	return rows.Err()
}

// UpsertBinding executes the 'UpsertBinding' query.
func UpsertBinding(ctx context.Context, e sqlx.ExtContext, params *UpsertBindingParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, UpsertBindingQuery, params)
}

// DeleteBinding executes the 'DeleteBinding' query.
func DeleteBinding(ctx context.Context, e sqlx.ExtContext, params *DeleteBindingParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, DeleteBindingQuery, params)
}

// GetCredentialsBySubjectID executes the 'GetCredentialsBySubjectID' query and returns a single row.
func GetCredentialsBySubjectID(ctx context.Context, db sqlx.ExtContext, params *GetCredentialsBySubjectIDParams) (*VaultCredentialEntity, error) {
	query, args, err := sqlx.Named(GetCredentialsBySubjectIDQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item VaultCredentialEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// GetCredentialsByIdentifier executes the 'GetCredentialsByIdentifier' query and returns a single row.
func GetCredentialsByIdentifier(ctx context.Context, db sqlx.ExtContext, params *GetCredentialsByIdentifierParams) (*VaultCredentialEntity, error) {
	query, args, err := sqlx.Named(GetCredentialsByIdentifierQuery, params)
	if err != nil {
		return nil, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item VaultCredentialEntity
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return nil, err
	}

	return &item, nil
}

// ExistsCredentialsByUsername executes the 'ExistsCredentialsByUsername' query and returns a single row.
func ExistsCredentialsByUsername(ctx context.Context, db sqlx.ExtContext, params *ExistsCredentialsByUsernameParams) (bool, error) {
	query, args, err := sqlx.Named(ExistsCredentialsByUsernameQuery, params)
	if err != nil {
		return false, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item bool
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return false, err
	}

	return item, nil
}

// ExistsCredentialsByEmail executes the 'ExistsCredentialsByEmail' query and returns a single row.
func ExistsCredentialsByEmail(ctx context.Context, db sqlx.ExtContext, params *ExistsCredentialsByEmailParams) (bool, error) {
	query, args, err := sqlx.Named(ExistsCredentialsByEmailQuery, params)
	if err != nil {
		return false, err
	}

	query = sqlx.Rebind(sqlx.DOLLAR, query)

	var item bool
	if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {
		return false, err
	}

	return item, nil
}

// UpsertCredentials executes the 'UpsertCredentials' query.
func UpsertCredentials(ctx context.Context, e sqlx.ExtContext, params *UpsertCredentialsParams) (sql.Result, error) {
	return sqlx.NamedExecContext(ctx, e, UpsertCredentialsQuery, params)
}
