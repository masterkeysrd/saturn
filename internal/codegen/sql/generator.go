package sqlgen

import (
	"bytes"
	"go/format"
	"os"

	"github.com/jmoiron/sqlx"
)

type Config struct {
	Package     string
	Schema      string
	ModelSuffix string
	FilePath    string
	QueryPath   string
	QuerySuffix string
}

func Generate(config Config, db *sqlx.DB) error {
	file := NewFile(bytes.Buffer{})

	inspector := NewInspector(db)
	tables, err := inspector.ListTables(config.Schema)
	if err != nil {
		return err
	}

	// Read queries from the specified query file
	queryContent, err := os.ReadFile(config.QueryPath)
	if err != nil {
		return err
	}

	parser := NewParser(db)
	queries, err := parser.Parse(bytes.NewReader(queryContent))
	if err != nil {
		return err
	}

	file.P("// Code generated by sqlgen. DO NOT EDIT.")
	file.P("package ", config.Package)
	file.P("")

	file.P("import (")
	imports := map[string]struct{}{}
	for _, table := range tables {
		for _, col := range table.Columns {
			if col.ImportPath != "" {
				imports[col.ImportPath] = struct{}{}
			}
		}
	}
	for _, query := range queries {
		for _, param := range query.Params {
			if param.GoImport != "" {
				imports[param.GoImport] = struct{}{}
			}
		}
	}

	for imp := range imports {
		file.P("  \"", imp, "\"")
	}
	file.P(")")
	file.P("")

	generateQueryConstants(file, queries)
	for _, table := range tables {
		err := generateModel(file, table, config)
		if err != nil {
			return err
		}
	}

	for _, query := range queries {
		err := generateQueryTypes(file, query)
		if err != nil {
			return err
		}
	}

	content, err := format.Source(file.Bytes())
	if err != nil {
		return err
	}

	return writeFile(config.FilePath, content)
}

func generateModel(f *File, table TableDef, config Config) error {
	structName := table.GoName + config.ModelSuffix
	f.P("// ", structName, " represents a row from the '", table.Name, "' table.")
	f.P("type ", structName, " struct {")
	for _, col := range table.Columns {
		goType := col.GoType
		if col.IsNullable {
			goType = "*" + goType
		}
		f.P("  ", col.GoName, " ", goType, " `db:\"", col.Name, "\"`")
	}
	f.P("}")
	f.P("")
	return nil
}

func generateQueryTypes(f *File, query QueryDef) error {
	// Generate parameter struct
	paramStructName := query.GoName + "Params"
	f.P("// ", paramStructName, " represents the parameters for the '", query.Name, "' query.")
	if query.CustomParamType != "" {
		f.P("//")
		f.P("// ", paramStructName, " is an alias of [", query.CustomParamType, "].")
		f.P("type ", paramStructName, " = ", query.CustomParamType)
		f.P("")
		return nil
	}

	f.P("type ", paramStructName, " struct {")
	for _, param := range query.Params {
		goType := param.Type
		if param.IsNullable {
			goType = "*" + goType
		}
		f.P("  ", param.GoName, " ", goType, " `db:\"", param.Name, "\"`")
	}
	f.P("}")
	f.P("")

	return nil
}

func generateQueryConstants(f *File, queries []QueryDef) {
	f.P("const (")
	for _, query := range queries {
		f.P("// ", query.GoName, "Query is the SQL for the '", query.Name, "' query.")
		f.P("  ", query.GoName, "Query = `\n", query.OriginalSQL, "`")
		f.P("")
	}
	f.P(")")
	f.P("")
}

func writeFile(filePath string, content []byte) error {
	return os.WriteFile(filePath, content, 0o644)
}
