package sqlgen

import (
	"bytes"
	"go/format"
	"log"
	"os"

	"github.com/jmoiron/sqlx"
)

type Config struct {
	Package     string
	Schema      string
	ModelSuffix string
	FilePath    string
	QueryPath   string
	QuerySuffix string
}

func Generate(config Config, db *sqlx.DB) error {
	file := NewFile(bytes.Buffer{})

	inspector := NewInspector(db)
	tables, err := inspector.ListTables(config.Schema)
	if err != nil {
		return err
	}

	// Read queries from the specified query file
	queryContent, err := os.ReadFile(config.QueryPath)
	if err != nil {
		return err
	}

	parser := NewParser(db)
	queries, err := parser.Parse(bytes.NewReader(queryContent))
	if err != nil {
		return err
	}

	file.P("// Code generated by sqlgen. DO NOT EDIT.")
	file.P("package ", config.Package)
	file.P("")

	file.P("import (")
	imports := map[string]struct{}{}
	for _, table := range tables {
		for _, col := range table.Columns {
			if col.ImportPath != "" {
				imports[col.ImportPath] = struct{}{}
			}
		}
	}
	for _, query := range queries {
		imports["context"] = struct{}{}
		imports["github.com/jmoiron/sqlx"] = struct{}{}

		if query.Cmd == "exec" {
			imports["database/sql"] = struct{}{}
		}

		for _, param := range query.Params {
			if param.GoImport != "" {
				imports[param.GoImport] = struct{}{}
			}
		}
	}

	for imp := range imports {
		file.P("  \"", imp, "\"")
	}
	file.P(")")
	file.P("")

	generateQueryConstants(file, queries)
	for _, table := range tables {
		err := generateModel(file, table, config)
		if err != nil {
			return err
		}
	}

	for _, query := range queries {
		err := generateParamStructs(file, query)
		if err != nil {
			return err
		}
	}

	generateFunctions(file, queries)

	content, err := format.Source(file.Bytes())
	if err != nil {
		return err
	}

	return writeFile(config.FilePath, content)
}

func generateModel(f *File, table TableDef, config Config) error {
	structName := table.GoName + config.ModelSuffix
	f.P("// ", structName, " represents a row from the '", table.Name, "' table.")
	f.P("type ", structName, " struct {")
	for _, col := range table.Columns {
		goType := col.GoType
		if col.IsNullable {
			goType = "*" + goType
		}
		f.P("  ", col.GoName, " ", goType, " `db:\"", col.Name, "\"`")
	}
	f.P("}")
	f.P("")
	return nil
}

func generateParamStructs(f *File, query QueryDef) error {
	// Generate parameter struct
	paramStructName := query.GoName + "Params"
	f.P("// ", paramStructName, " represents the parameters for the '", query.Name, "' query.")
	if query.CustomParamType != "" {
		f.P("//")
		f.P("// ", paramStructName, " is an alias of [", query.CustomParamType, "].")
		f.P("type ", paramStructName, " = ", query.CustomParamType)
		f.P("")
		return nil
	}

	f.P("type ", paramStructName, " struct {")
	for _, param := range query.Params {
		goType := param.Type
		if param.IsNullable {
			goType = "*" + goType
		}
		f.P("  ", param.GoName, " ", goType, " `db:\"", param.Name, "\"`")
	}
	f.P("}")
	f.P("")

	return nil
}

func generateQueryConstants(f *File, queries []QueryDef) {
	f.P("const (")
	for _, query := range queries {
		f.P("// ", query.GoName, "Query is the SQL for the '", query.Name, "' query.")
		f.P("  ", query.GoName, "Query = `\n", query.OriginalSQL, "`")
		f.P("")
	}
	f.P(")")
	f.P("")
}

func generateFunctions(f *File, queries []QueryDef) {
	for _, query := range queries {
		switch query.Cmd {
		case "many":
			generateManyFunction(f, query)
		case "exec":
			generateExecFunction(f, query)
		case "one":
			generateOneFunction(f, query)
		default:
			log.Printf("unknown query command: %s", query.Cmd)
		}
	}
}

func generateOneFunction(f *File, query QueryDef) {
	zeroVal, isNative := isNativeType(query.ReturnType)

	returnType := query.ReturnType
	if !isNative {
		returnType = "*" + query.ReturnType
	}

	returnErr := "err"
	if isNative {
		returnErr = zeroVal + ", err"
	} else {
		returnErr = "nil, err"
	}

	f.P("// ", query.GoName, " executes the '", query.Name, "' query and returns a single row.")
	f.P("func ", query.GoName, "(ctx context.Context, db sqlx.ExtContext, params *", query.GoName, "Params) (", returnType, ", error) {")
	f.P("  query, args, err := sqlx.Named(", query.GoName, "Query, params)")
	f.P("  if err != nil {")
	f.P("    return ", returnErr)
	f.P("  }")
	f.P("")
	f.P("  query = sqlx.Rebind(sqlx.DOLLAR, query)")
	f.P("")
	f.P("  var item ", query.ReturnType)
	f.P("  if err := sqlx.GetContext(ctx, db, &item, query, args...); err != nil {")
	f.P("    return ", returnErr)
	f.P("  }")
	f.P("")
	if isNative {
		f.P("  return item, nil")
	} else {
		f.P("  return &item, nil")
	}
	f.P("}")
}

func generateManyFunction(f *File, query QueryDef) {
	f.P("// ", query.GoName, " executes the '", query.Name, "' query and returns multiple rows.")
	f.P("func ", query.GoName, "(ctx context.Context, db sqlx.ExtContext, params *", query.GoName, "Params, mapper func(*", query.ReturnType, ") error) error {")
	f.P("  rows, err := sqlx.NamedQueryContext(ctx, db,", query.GoName, "Query, params)")
	f.P("  if err != nil {")
	f.P("    return err")
	f.P("  }")
	f.P("  defer rows.Close()")
	f.P("")
	f.P("  for rows.Next() {")
	f.P("    var item ", query.ReturnType)
	f.P("    if err := rows.StructScan(&item); err != nil {")
	f.P("      return err")
	f.P("    }")
	f.P("    if err := mapper(&item); err != nil {")
	f.P("      return err")
	f.P("    }")
	f.P("  }")
	f.P("")
	f.P("  return rows.Err()")
	f.P("}")
}

func generateExecFunction(f *File, query QueryDef) {
	f.P("// ", query.GoName, " executes the '", query.Name, "' query.")
	f.P("func ", query.GoName, "(ctx context.Context, e sqlx.ExtContext, params *", query.GoName, "Params) (sql.Result, error) {")
	f.P("  return sqlx.NamedExecContext(ctx, e,", query.GoName, "Query, params)")
	f.P("}")
}

func writeFile(filePath string, content []byte) error {
	return os.WriteFile(filePath, content, 0o644)
}

func isNativeType(goType string) (string, bool) {
	nativeTypes := map[string]string{
		"int":     "0",
		"int8":    "0",
		"int16":   "0",
		"int32":   "0",
		"int64":   "0",
		"uint":    "0",
		"uint8":   "0",
		"uint16":  "0",
		"uint32":  "0",
		"uint64":  "0",
		"float32": "0.0",
		"float64": "0.0",
		"string":  `""`,
		"bool":    "false",
		"byte":    "0",
		"rune":    "0",
	}

	zeroValue, ok := nativeTypes[goType]
	return zeroValue, ok
}
